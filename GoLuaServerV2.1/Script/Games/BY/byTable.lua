---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2018/11/1 14:59
---



--local CMD_Game_pb = require("CMD_Game_pb")

ByTable = BaseRoom:New()
function ByTable:New(roomId,gameTypeId)
    -- 重新赋值某些属性值
    o = BaseRoom:New()
    o.GameID              = gameTypeId
    o.roomId             = roomId
    o.TableMax            = BY_TABLE_MAX_PLAYER
    local father = getmetatable(o)
    setmetatable(self, father)
    o.super = setmetatable({},father)

    -- 椅子
    o.UserSeatArray         = {}        -- 座椅对应玩家uid的哈希表 ， key ： seatID (1,2,3,4)   ，value： player
    o.UserSeatArrayNumber   = 0         -- 房间上有几个玩家， 记住，这里不能用#UserSeatArray, 因为有可能中间有椅子是空的，不连续的不能用#， 本质UserSeatArray是map ；  也不能遍历， 慢

    -- 生成编号
    o.GenerateFishUid       = 1         -- 生成鱼的uid
    o.GenerateBulletUid     = 1         -- 生成子弹的uid

    -- 鱼
    o.FishArray             = {}        -- 鱼的哈希表    uid, fish         --- 要注意， key 不能用数字，因为占用内存太大， goperlua的问题
    o.FishArrayNumber       = 0         -- 鱼数组的长度，因为是哈希，所以记录一下比较方便

    -- 子弹
    o.BulletArray           = {}        -- 子弹的哈希表   id,  bullet         --- 要注意， key 不能用数字，因为占用内存太大， goperlua的问题
    o.BulletArrayNumber     = 0         -- 子弹数组的长度，因为是哈希，所以记录一下比较方便

    -- 生成鱼池
    o.DistributeArray       = {}        -- 鱼的生成信息数据    key顺序生成1,2,3,4...  Distribute
    o.BossDistributeArray   = {}        -- Boss鱼的生成信息数组 key顺序生成1,2,3,4...  Distribute

    setmetatable(o,self)
    self.__index = self
    return o
end

function ByTable:Reload(c)
    setmetatable(c, self)
    self.__index = self

    -- 如果热更新有改动成员变量的定义的话， 下面需要进行成员变量的处理
    -- 比如 1 增加了字段， 那么你需要将老数据进行， 新字段的初始化
    -- 比如 2 删除了字段， 那么你需要将老数据进行， 老字段=nil
    -- 比如 3 修改了字段， 那么你需要将老数据进行， 老字段=nil， 新字段初始化或者进行赋值处理
end

------------主循环-------------------
function ByTable:StartTable()
    self:InitTable()        -- 可以进行初始化
end

-- 房间的主循环
function ByTable:RunTable()
    if self:CheckTableEmpty() then
        --print("这是一个空房间")

        -- 这部分是做一个内存的测试
        ---- create Global Map hash
        --for i=1,40 do
        --    GlobalMap[tostring(i)] = i
        --end
        --
        --for i=1,40 do
        --    GlobalMap[tostring(i)] = nil
        --end

        --table.foreach(GlobalMap,function(i,v)
        --     print(i,v)
        --end )

        --clear  Global Map hash element
        --for i,_ in pairs(GlobalMap)do
        --    GlobalMap[tostring(i)] = nil        -- memery leak
        --end
        --
        --

        ---- if you clear all data, it's ok, but,  if you clear some data,  memery leak
        ----GlobalMap = {}
        --collectgarbage()

        self.LastRunTime = GetOsTimeMillisecond()
    else
        local now = GetOsTimeMillisecond()

        if self:GetFishNum() < MAX_Fish_NUMBER then
            self:RunDistributeInfo(table.RoomScore)
            self:RunBossDistributeInfo(table.RoomScore)
        end
        for _, bullet in pairs(self.BulletArray) do
            if now > bullet.DeadTime then
                self:DelBullet(bullet.BulletUID)     -- 生存时间已经到了，销毁
            end
            --bullet:BulletRun(now,self)      -- 遍历所有子弹，并且run
        end
        for _, fish in pairs(self.FishArray) do
            if now > fish.DeadTime then
                --print("鱼生存时间到了",self.FishUID)
                self:DelFish(fish.FishUID)
            end
            --fish:FishRun(now,self)              --遍历所有鱼，并且run
        end

        -- 记录房间的运行状态
        if now - self.LastRunTime > 1000 * 60  then     -- 60秒记录一次
            local state = {}
            state["FishNum"] = self:GetFishNum()        --当前有多少条鱼
            state["BulletNum"] = self:GetBulletNum()    --当前有多少子弹
            state["SeatArray"] = self.UserSeatArrayNumber    --当前有多少玩家
            SqlSaveGameState(self.GameID, self.roomId, state)
            self.LastRunTime = now
            --print("记录房间的运行状态")
        end
        -- 检查玩家的情况，如果玩家长期离线，那么t掉，没人就清空房间
        --for k, player in pairs(self.UserSeatArray) do
        --    if player.NetWorkState == false then
        --        if now - player.NetWorkCloseTimer > ConstPlayerNetworkWaitTime then
        --            -- 玩家长时间断线，t掉吧
        --            self:PlayerStandUp(player.ChairID,player)
        --            Logger("长时间断线， t掉这个玩家"..player.User.UserID)
        --        end
        --    end
        --end
        end
end



function ByTable:InitTable()
    if self:CheckTableEmpty() then
        -- 如果房间是空的， 那么需要初始化一下
        self:InitDistributeInfo()
    end
end


--- 判断玩家是否捕到鱼的逻辑判断   LockFishIdList 是保存fishId 的数组
function ByTable:LogicCatchFish(player, LockFishIdList, BulletId)
    print("玩家申请捕鱼")

    local bullet = self:GetBullet(BulletId)
    if bullet == nil then
        LuaNetWorkSendToUser(player.User.UserID,MDM_GF_GAME, SUB_S_CATCH_FISH,nil,"子弹的uid不正确", nil)
        return
    end

    local ALLCurrScore = 0   -- 获得的分数
    local AllFishes = {}     -- 抓获的鱼list

    --printTable(LockFishIdList)
    for _,fishId in ipairs(LockFishIdList) do
--        print("抓鱼uid",v)
        local fish = self:GetFish(fishId)
        if fish ~= nil then

            -- 这里判断鱼是否可以被捕获
            local isCatchFish = false

            -- 以后增加击中鱼之后的计算
            -- ...

            isCatchFish = true

            if isCatchFish then
                fish.CurrScore = tonumber( self:GetFishScore(fish))   --鱼的分数
                ALLCurrScore = ALLCurrScore + fish.CurrScore

                table.insert(AllFishes,fish)
                --AllFishes[fish.FishUID] = fish
                -- 删除鱼
                self:DelFish(fish.FishUID)
            end

        end
    end

    if #AllFishes == 0 then
        LuaNetWorkSendToUser(player.User.UserID,MDM_GF_GAME, SUB_S_CATCH_FISH,nil,"要捕获的鱼id不正确或者已经被别人捕捉了", nil)
        return
    end

    --删除子弹
    self:DelBullet(BulletId)
    -- 获得鱼的金币
    player.User.Score = player.User.Score + ALLCurrScore

    --print("获得金币",ALLCurrScore)
    --print("当前金币",player.User.Score)
    --printTable(AllFishes)


    print("给玩家同步捕鱼信息")
    -- 给所有玩家同步一下，这个玩家捕到鱼了
    local sendCmd = CMD_Game_pb.CMD_S_CATCH_FISH()

    for _,fish in ipairs(AllFishes) do
        local cmd = sendCmd.catch_fishs:add()
        cmd.fish_uid = fish.FishUID
        cmd.fish_score = fish.CurrScore
    end

    sendCmd.chair_id = player.ChairID
    sendCmd.bullet.bullet_id = bullet.BulletUID
    sendCmd.curr_score = player.User.Score

    --self:SendMsgToAllUsers(MDM_GF_GAME, SUB_S_CATCH_FISH,sendCmd)

    LuaNetWorkSendToUser(player.User.UserID,MDM_GF_GAME, SUB_S_CATCH_FISH,sendCmd,nil, nil)     -- 回复给玩家
    self:SendMsgToOtherUsers(player.User.UserID, sendCmd, MDM_GF_GAME, SUB_S_CATCH_FISH)                -- 同步其他人


end




----------------------------------------------------------------------------
-----------------------------消息同步-----------------------------------------
----------------------------------------------------------------------------
----玩家登陆的时候,发送场景其他消息
--- @param player 玩家对象
function ByTable:SendTableSceneInfo(player)
    if player == nil then
        Logger("ByTable:SendTableSceneInfo player 对象nil")
        return
    end
    --1.发送场景Enter_scene信息
    self:SendEnterSceneInfo(player.User.userId)
    --2.发送场景中鱼信息
    self:SendSceneFishes(player.User.userId)
end

--- 同步场景信息
function ByTable:SendEnterSceneInfo(UserId)
    local sendCmd = CMD_Game_pb.CMD_S_ENTER_SCENE()
    sendCmd.scene_id = self.GameID
    sendCmd.table_id = self.roomId
    for index, player in pairs(self.UserSeatArray) do       -- 从房间传递过来的其他玩家信息，原来坐着的玩家信息
        if player ~= nil then
            local uu = sendCmd.table_users:add()
            uu.user_id = player.User.UserID
            uu.chair_id = index
        end
    end

    LuaNetWorkSendToUser(UserId, MDM_GF_GAME, SUB_S_ENTER_SCENE, sendCmd, nil, nil) --进入房间
end
----------------------------------------------------------------------------
-----------------------------生成鱼池-----------------------------------------
----------------------------------------------------------------------------
----初始化鱼池的生成组----------------------------
function ByTable:InitDistributeInfo()
    --print("初始化鱼池")
    local startId = self.RoomScore * 100
    local endId = startId + 100
    local distribute
    -- 获取所有key
    local excelFishKeys = GetExcelFishAllKeys()
    if excelFishKeys == nil then
        Logger("ByTable:InitDistributeInfo获取鱼配置表中的所有key错误")
        return
    end
    for i, fishKind in ipairs(excelFishKeys) do
        fishKind = tonumber(fishKind)
        if GetExcelFishValue(fishKind,"is_use") == 1 and (fishKind > startId and fishKind < endId) then
            distribute = FishDistribute:New()
            distribute.FishKindID = fishKind

            distribute.CreateTime = GetOsTimeMillisecond()               --生成时间
            distribute.DistributeIntervalTime = distribute:GetIntervalTime(fishKind)      --获取时间间隔

            if distribute.DistributeIntervalTime == 0 then
                distribute.DistributeIntervalTime = 1000            -- 这里有生成间隔是0的东西
            end

            local fishType = GetExcelFishValue(fishKind,"type")
            if fishType == FT_BOSS then
                table.insert(self.BossDistributeArray, distribute)  --加入到Boss鱼生成列表中
            else
                table.insert(self.DistributeArray, distribute)      --加入到普通鱼生成列表中
            end
        end
    end
--    print("房间初始化鱼池结束")
end

----循环鱼池的生成组
function ByTable:RunDistributeInfo(roomScore)
    --print("循环鱼池生成组")
    local now = GetOsTimeMillisecond()
    local fish_number = 0
    local fish_number_max = 4       -- 每秒最多几条鱼

    for _,Distribute in pairs(self.DistributeArray) do
        local kindId = Distribute.FishKindID
        -- 到下一个生成时间了, 那么我们来生成鱼吧

        --print("now",now,"Distribute.CreateTime",Distribute.CreateTime, " Distribute.DistributeIntervalTime", Distribute.DistributeIntervalTime)

        if now >  Distribute.CreateTime + Distribute.DistributeIntervalTime then
            --print("生成时间到了")
            --print("now",now,"Distribute.CreateTime",Distribute.CreateTime, " Distribute.DistributeIntervalTime", Distribute.DistributeIntervalTime)
            local createType = 0   --鱼怎么走
            local buildNum = 0      -- 鱼生成数量
            local max = GetExcelFishValue(kindId,"count_max")
            if max > 1 then
                -- 多生成几条鱼
                buildNum =  Distribute:GetCount(kindId)
--                print("随机生成"..buildNum.."条鱼")
                if buildNum < 1 then
                    buildNum = 1
                else
                    createType = 1  --生成一条路径的
                    if buildNum >=5 or ZRandomPercentRate(50) then
                        createType = 2  --位置要做偏移
                    end
                end
                Distribute.NextCreateTime = now
                Distribute.NextInterBuildTime = Distribute:GetCountFishTime(kindId)
            end
            Distribute.BuildNumber = buildNum
            Distribute.CreateTime = now
            Distribute.DistributeIntervalTime = Distribute:GetIntervalTime(kindId)
            Distribute.CreateType = createType                  --创建类型
            Distribute.FirstPathID = Distribute:GetPathType()    -- 获取路径

            -- 创建鱼
            self:DistributeNewFish(Distribute,0,0)
            fish_number = fish_number + 1
            if fish_number >= fish_number_max then
                return
            end

        end

        -- 多条鱼的判断
        if Distribute.BuildNumber > 1 then
            if now > Distribute.NextCreateTime + Distribute.NextInterBuildTime then
--                print("生成多条鱼"..kindId)
                local offsetX = 0
                local offsetY = 0
                Distribute.NextCreateTime = now
                Distribute.BuildNumber = Distribute.BuildNumber - 1
                Distribute.NextInterBuildTime = Distribute:GetCountFishTime(kindId)
                if Distribute.CreateType == 2 then
                    -- 位置偏移
                    offsetX = Distribute:GetOffsetXY()[1]
                    offsetY = Distribute:GetOffsetXY()[2]
                end
                -- 创建鱼
                self:DistributeNewFish(Distribute,offsetX,offsetY)
                fish_number = fish_number + 1
                if fish_number >= fish_number_max then
                    return
                end
            end
        end

    end
end

-----循环Boss鱼池的生成组
function ByTable:RunBossDistributeInfo(roomScore)

    --local now = GetOsTimeMillisecond()
    --for k,Distribute in pairs(self.BossDistributeArray) do
    --    --到下一个生成时间了, 那么我们来生成鱼吧
    --    if now > Distribute.CreateTime + Distribute.DistributeIntervalTime then
    --        local kindId = Distribute.FishKindID
    --        local buildNum = 1   -- 鱼生成数量
    --        Distribute.BuildNumber = buildNum
    --        Distribute.CreateTime = now
    --        Distribute.DistributeIntervalTime = Distribute:GetIntervalTime(kindId)
    --        Distribute.FirstPathID = Distribute:GetPathType()    -- 获取路径
    --
    --        self:DistributeNewFish(Distribute,0,0)
    --    end
    --end
end

