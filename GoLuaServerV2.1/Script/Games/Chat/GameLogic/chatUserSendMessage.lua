---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.zhengxh
--- DateTime: 2019/11/28 15:50
---

--------------------------------------------------------------------------------------
--- 玩家发送消息给好友
--------------------------------------------------------------------------------------

--- 玩家发送消息给好友
--- @param player   玩家对象
--- @param data     消息数据
function ChatTable:HandleUserSendMessage(player, data)
    -- 玩家判定
    if player == nil or player.ChatUser == nil then
        Logger("ChatTable:HandleUserSendMessage 玩家不存在")
        return
    end
    -- 解析消息
    local receiveMsg = CMD_GlobalServer_pb.CMD_C_CHAT_MESSAGE()
    receiveMsg:ParseFromString(data)

    -- 响应返回消息
    local sendMsg = CMD_GlobalServer_pb.CMD_S_CHAT_MESSAGE()
    -- 说话人ID
    local dwSpeakID = receiveMsg.speaker_user_id
    if player.User.UserID ~= dwSpeakID then
        sendMsg.result = Enum_ReplyResult.Failed
        LuaNetWorkSendToUser(player.User.UserID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg)
        return
    end
    -- 接收人ID
    local dwReceiveID = receiveMsg.friend_user_id
    if dwReceiveID == dwSpeakID then
        sendMsg.result = Enum_ReplyResult.Failed
        LuaNetWorkSendToUser(dwSpeakID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg)
        return
    end
    if player:IsInFriendArray(dwReceiveID) == 0 then
        sendMsg.result = Enum_ReplyResult.Failed
        LuaNetWorkSendToUser(dwSpeakID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg)
        return
    end
    local curTime = os.time()
    -- 聊天间隔判定
    if player.ChatWithFriendInterval + ChatWithFriendInterval > curTime then
        sendMsg.result = Enum_ReplyResult.Failed
        LuaNetWorkSendToUser(dwSpeakID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg)
        return
    end
    player.ChatWithFriendInterval = curTime
    -- 消息内容
    local strMsg = receiveMsg.msg
    -- 消息长度判定
    if string.len(strMsg) > ChatMsgLength then
        sendMsg.result = Enum_ReplyResult.Failed
        LuaNetWorkSendToUser(dwSpeakID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg)
        return
    end
    -- 非法字符处理
    strMsg = self:DealConfineContent(strMsg)
    -- 表情
    local dwEmotion = receiveMsg.emotion
    -- 组装返回消息
    sendMsg.speaker_user_id = dwSpeakID                     -- 说话人ID
    sendMsg.friend_user_id  = dwReceiveID                   -- 接收人ID
    sendMsg.msg.id          = 1                             -- 消息ID
    sendMsg.msg.msg         = strMsg                        -- 消息内容
    sendMsg.msg.emotion     = dwEmotion                     -- 表情
    sendMsg.msg.time_stamp  = curTime                       -- 发送时间
    sendMsg.result          = Enum_ReplyResult.Successful   -- 聊天结果
    LuaNetWorkSendToUser(dwSpeakID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg)
    -- 接收人处理
    local receivePlayer = GetPlayerByUID(dwReceiveID)
    if receivePlayer then
        -- 判定玩家未读消息列表
        local tbUnReadArray = receivePlayer:GetFriendUnReadMessage(dwSpeakID)
        if tbUnReadArray ~= nil and #tbUnReadArray > ApplyFriendListNum then
            return
        end
        -- 在线,给玩家未读列表加一条
        receivePlayer:AddFriendUnReadMessage(dwSpeakID, dwEmotion, strMsg)
        -- 通知有新消息

    else
        -- 不在线，取Redis
        local receiveChatUser = RedisGetPlayerChatInfo(dwReceiveID)
        if receiveChatUser.UnReadMessageArray[tostring(dwSpeakID)] == nil then
            receiveChatUser.UnReadMessageArray[tostring(dwSpeakID)] = {}
        elseif #receiveChatUser.UnReadMessageArray[tostring(dwSpeakID)] > ApplyFriendListNum then
            -- 判定玩家未读消息列表
            return
        end
        table.insert(receiveChatUser.UnReadMessageArray[tostring(dwSpeakID)], {
            dwEmotion,
            curTime,
            strMsg
        })
        -- 保存Redis
        RedisSavePlayerChatInfo(dwReceiveID, receiveChatUser)
    end
end