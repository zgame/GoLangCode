---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.
--- DateTime: 2019/11/15 17:43

--- 客户端请求的消息处理



---获取未读聊天信息
---@param serverId 服务器id
---@param userId 用户id
---@param data 数据
---@param token
function ChatServerLogic:ClientSubGetChatUnreadMessage(serverId, userId, data, token)
    local userInfo = self.UserMgr:FindUserInfoPtrByUserID(userId)
    if userInfo == nil then
        return false
    end
    local friendRelation = self.FriendMgr:GetFriendRelation(userId)
    if friendRelation == nil then
        return false
    end
    local recvMsg =  CMD_GlobalServer_pb.CMD_C_GET_CHAT_MESSAGE()
    recvMsg:ParseFromString(data)
    ---好友ID
    local nFriendID = recvMsg.friend_user_id
    --- 目标玩家是否是好友
    if not friendRelation:IsExistedFriend(nFriendID) then
        return true
    end
    local sendMsg = CMD_GlobalServer_pb.CMD_S_GET_CHAT_MESSAGE()
    sendMsg.friend_user_id = nFriendID
    ---  获取未读消息缓存
    local pMsgCache = self.FriendMgr:GetUnreadMessageCache(userId)
    if pMsgCache ~= nil  then
        local lstMsg = pMsgCache:FetchUnreadMessage(nFriendID)
        --printTable(lstMsg,0,"ClientSubGetChatMessage.lstMsg")
        --Logger('ChatServerLogic:ClientSubGetChatMessage #lstMsglen =' .. #lstMsg)
        for _,msg in pairs(lstMsg) do
            local chatPacker = sendMsg.msg_list:add()
            chatPacker.id = friendRelation:GenerateMessageID()
            chatPacker.emotion = msg.dwEmotion
            chatPacker.time_stamp = msg.tTimeStamp
            chatPacker.msg = msg.sAfterFilterContent
        end
    end
    -- 发送消息
    LuaNetWorkSendToUser(userId, MAIN_CHAT_SERVICE_CLIENT, SUB_S_GET_CHAT_MESSAGE, sendMsg);
end


---聊天信息
---@param serverId 服务器id
---@param userId 用户id
---@param data 数据
---@param token
function ChatServerLogic:ClientSubChatMessage(serverId, userId, data, token)
    --- 查找用户
    local pUser = self.UserMgr:FindUserInfoPtrByUserID(userId)
    if pUser == nil then
        return false
    end

    --- 查找关系
    --- @type ChatFriendRelation
    local pFriends = self.FriendMgr:GetFriendRelation(userId)
    if pFriends == nil then
        return false
    end
    local recvMsg = CMD_GlobalServer_pb.CMD_C_CHAT_MESSAGE()
    recvMsg:ParseFromString(data)
    -- 不是用户再说话
    --print(recvMsg)
    if pUser.UserId ~= recvMsg.speaker_user_id then
        return false
    end
    -- 好友ID
    local nFriendID = recvMsg.friend_user_id;
    --- 不会存在自己给自己发消息
    if (pUser.UserId == nFriendID) then
        return false;
    end
    --- 检查是否可以聊天
    if not ChatServerUserInfo.CanChatWithFriend(pUser,nFriendID,ChatWithFriendInterval) then
        --if pUser:CanChatWithFriend(nFriendID, ChatWithFriendInterval) then
        return true
    end
    --print(string.format("ClientSubChatMessage:目前到步骤:%s","过了是否可以聊天"));
    --- 目标玩家是否是好友
    if not pFriends:IsExistedFriend(nFriendID) then
        return true
    end
    --- 构建消息结构
    --print(string.format("ClientSubChatMessage:目前到步骤:%s","过了好友判定"));
    local sendMsg = CMD_GlobalServer_pb.CMD_S_CHAT_MESSAGE()
    sendMsg.speaker_user_id = pUser.UserId
    sendMsg.friend_user_id = nFriendID
    local Message = ChatServerMessage:New(pFriends:GenerateMessageID())
    Message.dwEmotion = recvMsg.emotion
    Message.tTimeStamp = os.time()
    Message.sOriginalContent = recvMsg.msg
    local sOriginalContent = Message.sOriginalContent
    if string.len(sOriginalContent) > ChatMsgLength * 2 then
        sendMsg.result = Enum_ReplyResult.Failed
        LuaNetWorkSendToUser(userId, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg, nil)
        return false
    end
    ---　过滤屏蔽字
    Message.sAfterFilterContent = self:FliterConfineContent(sOriginalContent)
    --- 下发结果
    sendMsg.result = Enum_ReplyResult.Successful
    local chatPacker = sendMsg.msg
    chatPacker.id = Message.dwMsgID
    chatPacker.emotion = Message.dwEmotion
    chatPacker.time_stamp = Message.tTimeStamp
    chatPacker.msg = Message.sAfterFilterContent
    --sendMsg.msg = chatPacker
    LuaNetWorkSendToUser(userId, MAIN_CHAT_SERVICE_CLIENT, SUB_S_CHAT_MESSAGE, sendMsg, nil)

    ---@type ChatUnreadMessageCache
    local pFriendMsgCache = self.FriendMgr:GetUnreadMessageCache(nFriendID)
    if pFriendMsgCache == nil then
        pFriendMsgCache = self.FriendMgr:AddUnreadMessageCache(nFriendID)
    end
    if pFriendMsgCache ~= nil then
        pFriendMsgCache:SetLockState()

        --- 从数据库加载好友的未读消息
        --print(string.format("ClientSubChatMessage:玩家[%d]的未读消息的加载状态为【%d】",nFriendID,pFriendMsgCache.eState));
        self:DoLoadUserUnreadMsg(nFriendID)

        --pFriendMsgCache:
        --local tUnreadMessageFromUser = pFriendMsgCache:GetFriendUnreadMessageCache(userId);
        --if tUnreadMessageFromUser ~= nil and next(tUnreadMessageFromUser) then
        --    tUnreadMessageFromUser:ClearMsg();
        --end

        ---加入缓存
        --print(string.format("ClientSubChatMessage:玩家[%d]的未读消息的加载状态为【%d】",nFriendID,pFriendMsgCache.eState));
        pFriendMsgCache:AddUnreadOneMessage(pUser.UserId, Message)
        local pFriendUser = self.UserMgr:FindUserInfoPtrByUserID(nFriendID)
        if pFriendUser ~= nil then
            -- 是否拉取消息（设计目的：避免频繁/非必要拉取消息）
            local bNotifyPull = pFriendMsgCache:CanNotifyFriendNewMessage(pUser.UserId);
            -- 未读数量
            local iUnreadCount = pFriendMsgCache:GetFreindUnreadCount(pUser.UserId);
            --if iUnreadCount > 0 then
            --print(string.format("玩家[%d]有提示好友消息！【2】",pUser.UserId))
            --end
            self:NotifyNewState(nFriendID,iUnreadCount,bNotifyPull,pUser.UserId)
        end
    end

    -- 保存到消息表
    local WillSaveMessageTuple = ChatWillSaveMessage:New(userId, nFriendID, Message.dwEmotion, sOriginalContent)
    table.insert(self.m_WillSaveMessagelist, WillSaveMessageTuple)
end