
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.
--- DateTime: 2019/10/22 17:03
---


--- 处理客户端相关消息  用户登陆聊天服,用户离线,发送心跳

-- 客户端登录
---@param serverId 服务器id
---@param userId 用户id
---@param data 数据
---@param token
function ChatServerLogic:ClientSubLoginAction(serverId, userId, data, token)
    --print(string.format("ChatServerFace:ClientSubLoginAction:收到消息serverId=[%d],userId=[%d]", serverId, userId));
    local resMsg = CMD_GlobalServer_pb.CMD_C_LOGIN();
    resMsg:ParseFromString(data);
    --print(resMsg)
    --读取前端上传的参数，用于登陆验证
    local nUserID = resMsg.user_id;
    local nGameID = resMsg.game_id;
    local sToken = resMsg.token;
    local nRandNum = resMsg.rand;
    local nRandNum2 = resMsg.rand2;
    --初始化下发消息
    local sendCmd = CMD_GlobalServer_pb.CMD_S_LOGIN();
    --printTable(self.UserMgr.m_mapSearchCache, 0, "m_mapSearchCache")
    local tUserCache = self.UserMgr:FindUserInfoPtrByUserID(nUserID);
    --printTable(tUserCache);
    if (tUserCache == nil or ChatServerUserInfo.GetToken(tUserCache) ~= sToken) then
        local nTempData = Bit32Xor(Bit32Or(nUserID, nGameID), nRandNum);
        --生成时间
        local llCreateTime = Bit32Xor(nRandNum2, nTempData);
        --检查token
        local sSrc = "Im#Player!" .. nTempData .. "&(" .. nRandNum .. ")+" .. nRandNum2;
        local sRealToken = string.upper(MD5Get(sSrc));
        --print(string.format("sSrc=%s,sRealToken=%s,sToken=%s", sSrc, sRealToken, sToken))
        if sRealToken ~= sToken then
            print("非法连接，token不匹配：userid=" .. nUserID .. ",gameid=" .. nGameID .. ",rand=" .. nRandNum .. ",token=" .. sToken)
            return false;
        end
        --更改token
        if tUserCache then
            ChatServerUserInfo.SetToken(tUserCache,sToken);
            --tUserCache:SetToken(sToken);
        end
    end
    --// 玩家连接增加
    self.m_iPlayerCount = self.m_iPlayerCount + 1;
    --print("检查玩家是否已在线tUserCache",tUserCache)
    --检查玩家是否已在线
    if tUserCache then
        --如果是重新连接，这里暂时不处理
    else
        tUserCache = ChatServerUserInfo:New();
        --tUserCache.UserId = nUserID;
        --tUserCache.GameId = nGameID;
        tUserCache.sToken = sToken;
        local tDboData = self:OnLoadUserInfo(Enum_DBSearchType.UserID,nUserID)
        if tDboData ~= nil  and # tDboData > 0 then
            tUserCache = self:OnDBLoadUserInfo(nUserID, tDboData, tUserCache);
        else
            Logger(string.format("ClientSubLoginAction:玩家[userid=%d]未查询到玩家信息！",nUserID))
            return false;
        end
        ---登陆后将玩家信息写入redis。这里刷一次数据，处理玩家修改昵称等情况
        --printTable(tUserCache);
        self.UserMgr:SaveUserInfo2Redis(tUserCache);
    end
    --绑定serverId，nUserID，修改在线玩家数据
    luaCallGoResisterUID(nUserID, serverId);
    local player = Player:New(tUserCache);
    SetAllPlayerList(nUserID,player);
    --- 设置玩家的连接类型
    self:SetSocketLinkInfo(serverId, Enum_ChatServerLinkKind.Player)
    self.UserMgr:OnEventPlayerLogin(nUserID, tUserCache);
    --// 检查好友信息
    local tFriends = self.FriendMgr:GetFriendRelation(nUserID);
    if tFriends == nil then
        tFriends = self.FriendMgr:AddFriendRelation(nUserID);
        --获取好友信息
        --先加载好友
        self:DoLoadUserFriendsInfo(nUserID);
        --再加载申请列表
        self:DoLoadUserApplyInfo(nUserID);
        --最后加载被申请列表
        self:DoLoadUserByApplyInfo(nUserID);
    end
    --// 检查是否有未读缓存
    local tUnreadMsgCache = self.FriendMgr:GetUnreadMessageCache(nUserID);
    if tUnreadMsgCache == nil then
        tUnreadMsgCache = self.FriendMgr:AddUnreadMessageCache(nUserID);
        tUnreadMsgCache:SetLockState();
        --print("tUnreadMsgCache开始加载未读消息")
        --printTable(tUnreadMsgCache,0,"tUnreadMsgCache")
        self:DoLoadUserUnreadMsg(nUserID);
    end
    --登陆成功，下发客户端消息

    --printTable(self.UserMgr.m_mapUserInfoPtr, 0, "m_mapUserInfoPtr")
    sendCmd.result = Enum_ReplyResult.Successful
    LuaNetWorkSendToUser(nUserID, MAIN_CHAT_SERVICE_CLIENT, SUB_S_LOGIN, sendCmd, nil);

    if tUnreadMsgCache:IsThereAnyMessage() or tFriends:IsThereAnyBeAppliedForFriend() then
        ---print(string.format("---------------------------------------玩家%d有提示好友消息！【1】",nUserID))
        -----------------------------------------有提示好友消息
        self:NotifyNewState(nUserID, 1);
    end
end

---OnEventTCPNetworkShut：网络关闭时间
---@param dwUserID 玩家ID
function ChatServerLogic:OnEventTCPNetworkShut(dwUserID)
    self:OnTcpRecordOffLineTime(dwUserID);
    self.UserMgr:OnEventPlayerLogout(dwUserID);
    SetAllPlayerList(dwUserID,nil)
    self.m_iPlayerCount = self.m_iPlayerCount - 1;
end

---记录玩家离线相关的逻辑
---@param dwUserID 玩家ID
function ChatServerLogic:OnTcpRecordOffLineTime(dwUserID)
    ---print(string.format("OnTcpRecordOffLineTime:玩家[%d]离线处理",dwUserID))
    local tUserInfo = self.UserMgr:FindUserInfoPtrByUserID(dwUserID);
    if tUserInfo == nil then
        return ;
    end
    ---设置玩家离线时间
    self.UserMgr:SetUserOfflineTime(dwUserID,os.time())
    --离线时间写入数据库
    self:SaveUserOffLineTime(dwUserID);
end

---当从数据库获得玩家信息的时候处理
---@param dwUserID 玩家ID
---@param tDboData 数据
function ChatServerLogic:OnDBLoadUserInfo(dwUserID, tDboData, tUserCache)
    tUserCache.UserId = tDboData[1].UserID;
    tUserCache.GameId = tDboData[1].GameID;
    tUserCache.FaceId = tDboData[1].FaceID;
    tUserCache.VipLevel = tDboData[1].VipLev;
    tUserCache.NickName = tDboData[1].NickName;
    tUserCache.GuildID = tDboData[1].GuildID;
    tUserCache.GuildName = tDboData[1].GuildName;
    --print(tDboData[1].OffLineTime)
    --print(GetTimeFromString(tDboData[1].OffLineTime))
    tUserCache.llOffLineTime = GetTimeFromString(tDboData[1].OffLineTime);
    --printTable(tUserCache)
    tUserCache = self.UserMgr:AddUser(tUserCache);
    --printTable(tUserCache)
    self:AutoApplyFriend(tUserCache);
    return tUserCache;
end



--心跳消息
---@param serverId 服务器id
---@param userId 用户id
---@param data 数据
---@param token
function ChatServerLogic:ClientSubHeartbeat(serverId, userId, data, token)
    --print(string.format("ChatServerFace:ClientSubHeartbeat userId=%d",userId));
    local recvMsg = CMD_GlobalServer_pb.CMD_C_HEART_BEAT_CHAT();
    recvMsg:ParseFromString(data);
    if not recvMsg:ParseFromString(data) then
        return false;
    end
    local sendMsg = CMD_GlobalServer_pb.CMD_S_HEART_BEAT_CHAT();
    sendMsg.time_stamp = os.time();
    LuaNetWorkSendToUser(userId, MAIN_CHAT_SERVICE_CLIENT, SUB_S_HEARTBEAT_CHAT, sendMsg, nil);
    return true;
end
