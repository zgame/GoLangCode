---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.
--- DateTime: 2019/10/22 15:36

--- 好友未读消息结构


---未读消息缓存
---@class FriendUnreadMessage
FriendUnreadMessageCache = {}

---@return FriendUnreadMessage
function FriendUnreadMessageCache:New()
    local c = {
        lstMsg = {},--消息列表
        eState = FriendMsgListState.Normal,--消息状态
    }
    setmetatable(c, self)
    self.__index = self
    return c
end

--- 添加消息
function FriendUnreadMessageCache:AddMsg(msg)
    self.eState = FriendMsgListState.Update
    if msg ~= nil and msg.sOriginalContent ~= nil then
        msg.sOriginalContent = ""
    end
    table.insert(self.lstMsg,msg)
    if #self.lstMsg > 20 then
        --self.lstMsg[1] = nil
        table.remove(self.lstMsg,1)
    end
end

--- 添加旧的消息
function FriendUnreadMessageCache:AddOldMsg(vecNewMsg)
    local nCount = 0
    local nVecNewMsgSize = 0
    if vecNewMsg ~= nil then
        nVecNewMsgSize = #vecNewMsg
        nCount = nVecNewMsgSize
    end
    nCount = math.min(20 - #self.lstMsg,nCount)
    for i = 1,nCount do
        local msg = vecNewMsg[nVecNewMsgSize - i + 1]
        if msg ~= nil and msg.sOriginalContent ~= nil then
            msg.sOriginalContent = ""
            table.insert(self.lstMsg,1,msg)
        end
    end
end

function FriendUnreadMessageCache:ClearMsg()
    self.eState = FriendMsgListState.Update
    self.lstMsg = {}
    --table.remove(self.lstMsg)
end


--- 重新加载类
function FriendUnreadMessageCache:Reload(o)
    --- 重新刷一次元表,以便调用新定义方法，更新老方法
    G_SetMetaTable(o,self)
    -- 如果热更新有改动成员变量的定义的话， 下面需要进行成员变量的处理
    -- 比如 1 增加了字段， 那么你需要将老数据进行， 新字段的初始化
    -- 比如 2 删除了字段， 那么你需要将老数据进行， 老字段=nil
    -- 比如 3 修改了字段， 那么你需要将老数据进行， 老字段=nil， 新字段初始化或者进行赋值处理
end