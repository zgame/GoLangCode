---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by soonyo.
--- DateTime: 2019/10/22 15:38

--- 聊天时产生的未读消息

---@class ChatUnreadMessageCache
ChatUnreadMessageCache = {}

---@return ChatUnreadMessageCache
function ChatUnreadMessageCache:New(userID)
    local c = {
    dwUserID = userID,--玩家id
    mapFriendCache = {},--好友消息缓存列表
    lastUpdateTime = 0,--最后活跃时间
    eState = FriendMsgListState.Normal,--消息状态
    }
    setmetatable(c, self)
    self.__index = self
    return c
end

---写入未读消息
---@param dwFriendID 好友UID
---@param msg 消息的结构体
function ChatUnreadMessageCache:AddUnreadOneMessage(dwFriendID,msg)
    --printTable(msg,0,"AddUnreadMessage.msg")
    self.lastUpdateTime = os.time()
    if dwFriendID == 0 then
        return false
    end
    --- 锁定时不要更改状态
    if self.eState ~= FriendMsgListState.Locked then
        self.eState = FriendMsgListState.Update
    end
    local pCache = self:GetFriendUnreadMessageCache(dwFriendID)
    if pCache ~= nil then
        pCache:AddMsg(msg)
    end
    return true
end
---写入未读消息列表
---@param dwFriendID 消息的来源玩家的UID
---@param vecNewMsg 好友UID
function ChatUnreadMessageCache:AddUnreadMessage(dwFriendID,vecNewMsg)
    self.lastUpdateTime = os.time()
    if dwFriendID == 0 then
        return false
    end
    local tCache = self:GetFriendUnreadMessageCache(dwFriendID)
    if tCache == nil then
        return false
    end
    if self.eState == FriendMsgListState.Locked then
        tCache:AddOldMsg(vecNewMsg)
    else
        self.eState = FriendMsgListState.Update
        local nSize = 0
        if vecNewMsg ~= nil then
            nSize = #vecNewMsg
        end
        for i = 1,nSize do
            tCache:AddMsg(vecNewMsg[i]);
        end
    end
    --- self.mapFriendCache[tostring(dwFriendID)] = tCache
    --printTable(self.mapFriendCache,0,string.format("self.mapFriendCache[%d]",self.dwUserID))
    return true
end
--拉取好友未读消息。注意，这个接口附带将未读消息清空！
---@param dwFriendID好友的UserID
function ChatUnreadMessageCache:FetchUnreadMessage(dwFriendID)
    self.lastUpdateTime = os.time()
    local lst = {}
    --print("FetchUnreadMessage.lst的地址",lst)
    local pCache = self:GetFriendUnreadMessageCache(dwFriendID)
    if pCache == nil or self.eState == FriendMsgListState.Locked  then
        return lst;
    end
    self.eState = FriendMsgListState.Update
    lst = pCache.lstMsg
    --print("FetchUnreadMessage:pCache.lstMsg的地址",pCache.lstMsg)
    --print("FetchUnreadMessage.lst的地址",lst)
    --printTable(pCache.lstMsg,0,"FetchUnreadMessage:pCache.lstMsg")
    pCache:ClearMsg()
    --printTable(pCache.lstMsg,0,"FetchUnreadMessage:pCache.lstMsg")
    --print("FetchUnreadMessage:pCache.lstMsg的地址",pCache.lstMsg)
    --printTable(lst,0,"FetchUnreadMessage:lst")
    --print("FetchUnreadMessage.lst的地址",lst)
    return lst
end
---获取好友未读消息数量
---@param dwFriendID 好友UID
function ChatUnreadMessageCache:GetFreindUnreadCount(dwFriendID)
    local tCache = self:GetFriendUnreadMessageCache(dwFriendID)
    --printTable(tCache,0,"GetFreindUnreadCount.tCache")
    if tCache == nil or not next(tCache)  then
        return 0
    else
        return #tCache.lstMsg
    end
end
---获取好友最新消息时间
---@param dwFriendID 好友UID
function ChatUnreadMessageCache:GetFreindUnreadMsgTime(dwFriendID)
    local tCache = self:GetFriendUnreadMessageCache(dwFriendID)
    if tCache == nil or next(tCache.lstMsg) == nil  then
        return 0
    end
    local msgSize = #tCache.lstMsg
    return tCache.lstMsg[msgSize].tTimeStamp
end
---设置锁定状态。将玩家的消息设为锁定，将不能读取，需等待更新完成
function ChatUnreadMessageCache:SetLockState()
   self.eState = FriendMsgListState.Locked
end
---解除锁定
function ChatUnreadMessageCache:UnlockState()
    self.eState = FriendMsgListState.Update
end
--- 是否可以通知好友有新消息
---@param dwFriendID 需要通知的好友的UID
function ChatUnreadMessageCache:CanNotifyFriendNewMessage(dwFriendID)
    if self.eState == FriendMsgListState.Locked then
        return false
    end
    local tCatche = self:GetFriendUnreadMessageCache(dwFriendID)
    if tCatche ~= nil  and tCatche.lstMsg ~= nil then
        return #tCatche.lstMsg == 1
    end
    return false
end
---获取待保存的消息列表
---@param vecMsg 需要写入的消息数组
function ChatUnreadMessageCache:GetWillSaveMessageList(vecMsg)
    --printTable(self,0,"GetWillSaveMessageList")
    vecMsg = vecMsg or {}
    if self.eState ~= FriendMsgListState.Update then
        return vecMsg
    end
    for key,value in pairs(self.mapFriendCache) do
        if value.eState == FriendMsgListState.Update then
            value.eState = FriendMsgListState.Normal
            local nMsgSize = #value.lstMsg
            local tVecMsg = {}
            tVecMsg[1] = self.dwUserID
            tVecMsg[2] = tonumber(key)
            tVecMsg[3] = nMsgSize
            local szMag = ""
            --printTable(value.lstMsg,0,"GetWillSaveMessageList.value.lstMsg=")
            for i = 1,nMsgSize do
                szMag = string.format("%s%d%s%d%s%s%s",szMag,value.lstMsg[i].dwEmotion,MESSAGE_FIELD_SPARATE,value.lstMsg[i].tTimeStamp,MESSAGE_FIELD_SPARATE,value.lstMsg[i].sAfterFilterContent,MESSAGE_SPARATE)
            end
            tVecMsg[4] = szMag
            --print(string.format("GetWillSaveMessageList.szMag=%s",szMag));
            table.insert(vecMsg,tVecMsg)
        end
        --table.insert(vecMsg,tVecMsg)
    end
    return vecMsg;
end
----获取最后活跃时间
function ChatUnreadMessageCache:GetLastUpdateTime()
    return self.lastUpdateTime
end
---@return boolean
function ChatUnreadMessageCache:IsThereAnyMessage()--是否有未读消息
    if self.eState == FriendMsgListState.Locked then
        return false
    end
    --printTable(self.mapFriendCache,0,"self.mapFriendCache")
    --printTable(self,0,string.format("ChatUnreadMessageCache[%d]",self.dwUserID))
    for _,value in pairs(self.mapFriendCache) do
        if value.lstMsg ~= nil and #value.lstMsg > 0 then
            return true
        end
    end
    return false
end
---获取好友未读消息
---@param dwFriendID 好友UID
function ChatUnreadMessageCache:GetFriendUnreadMessageCache(dwFriendID)
    if dwFriendID == nil or type(dwFriendID) ~= "number" then
        return nil
    end
    ---c++ 代码没有这个处理 這裡要添加 因为mapFriendCache沒有初始化
    local tCache = self.mapFriendCache[tostring(dwFriendID)];
    if tCache == nil then
        tCache = FriendUnreadMessageCache:New()
        self.mapFriendCache[tostring(dwFriendID)] = tCache;
    end
    return tCache
end


function ChatUnreadMessageCache:Reload(o)
    --- 重新刷一次元表,以便调用新定义方法，更新老方法
    G_SetMetaTable(o,self)
    for userID,friendUnreadCache in pairs(self.mapFriendCache)  do
        FriendUnreadMessageCache:Reload(self.mapFriendCache[userID])
    end
    -- 如果热更新有改动成员变量的定义的话， 下面需要进行成员变量的处理
    -- 比如 1 增加了字段， 那么你需要将老数据进行， 新字段的初始化
    -- 比如 2 删除了字段， 那么你需要将老数据进行， 老字段=nil
    -- 比如 3 修改了字段， 那么你需要将老数据进行， 老字段=nil， 新字段初始化或者进行赋值处理
end